// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: message_receipts.sql

package storage

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countMessageDeliveries = `-- name: CountMessageDeliveries :one
SELECT COUNT(*) FROM message_receipts
WHERE message_id = $1 AND delivered_at IS NOT NULL
`

func (q *Queries) CountMessageDeliveries(ctx context.Context, messageID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countMessageDeliveries, messageID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMessageReads = `-- name: CountMessageReads :one
SELECT COUNT(*) FROM message_receipts
WHERE message_id = $1 AND read_at IS NOT NULL
`

func (q *Queries) CountMessageReads(ctx context.Context, messageID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countMessageReads, messageID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createMessageReceipt = `-- name: CreateMessageReceipt :one
INSERT INTO message_receipts (
  message_id, user_id, delivered_at, read_at
) VALUES (
  $1, $2, $3, $4
)
RETURNING message_id, user_id, delivered_at, read_at
`

type CreateMessageReceiptParams struct {
	MessageID   pgtype.UUID
	UserID      pgtype.UUID
	DeliveredAt pgtype.Timestamptz
	ReadAt      pgtype.Timestamptz
}

func (q *Queries) CreateMessageReceipt(ctx context.Context, arg CreateMessageReceiptParams) (MessageReceipt, error) {
	row := q.db.QueryRow(ctx, createMessageReceipt,
		arg.MessageID,
		arg.UserID,
		arg.DeliveredAt,
		arg.ReadAt,
	)
	var i MessageReceipt
	err := row.Scan(
		&i.MessageID,
		&i.UserID,
		&i.DeliveredAt,
		&i.ReadAt,
	)
	return i, err
}

const deleteAllMessageReceipts = `-- name: DeleteAllMessageReceipts :exec
DELETE FROM message_receipts
WHERE message_id = $1
`

func (q *Queries) DeleteAllMessageReceipts(ctx context.Context, messageID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteAllMessageReceipts, messageID)
	return err
}

const deleteMessageReceipt = `-- name: DeleteMessageReceipt :exec
DELETE FROM message_receipts
WHERE message_id = $1 AND user_id = $2
`

type DeleteMessageReceiptParams struct {
	MessageID pgtype.UUID
	UserID    pgtype.UUID
}

func (q *Queries) DeleteMessageReceipt(ctx context.Context, arg DeleteMessageReceiptParams) error {
	_, err := q.db.Exec(ctx, deleteMessageReceipt, arg.MessageID, arg.UserID)
	return err
}

const getMessageDeliveryStatus = `-- name: GetMessageDeliveryStatus :one
SELECT 
  COUNT(*) as total_recipients,
  COUNT(delivered_at) as delivered_count,
  COUNT(read_at) as read_count
FROM message_receipts
WHERE message_id = $1
`

type GetMessageDeliveryStatusRow struct {
	TotalRecipients int64
	DeliveredCount  int64
	ReadCount       int64
}

func (q *Queries) GetMessageDeliveryStatus(ctx context.Context, messageID pgtype.UUID) (GetMessageDeliveryStatusRow, error) {
	row := q.db.QueryRow(ctx, getMessageDeliveryStatus, messageID)
	var i GetMessageDeliveryStatusRow
	err := row.Scan(&i.TotalRecipients, &i.DeliveredCount, &i.ReadCount)
	return i, err
}

const getMessageReceipt = `-- name: GetMessageReceipt :one
SELECT message_id, user_id, delivered_at, read_at FROM message_receipts
WHERE message_id = $1 AND user_id = $2 LIMIT 1
`

type GetMessageReceiptParams struct {
	MessageID pgtype.UUID
	UserID    pgtype.UUID
}

func (q *Queries) GetMessageReceipt(ctx context.Context, arg GetMessageReceiptParams) (MessageReceipt, error) {
	row := q.db.QueryRow(ctx, getMessageReceipt, arg.MessageID, arg.UserID)
	var i MessageReceipt
	err := row.Scan(
		&i.MessageID,
		&i.UserID,
		&i.DeliveredAt,
		&i.ReadAt,
	)
	return i, err
}

const getMessageReceiptWithDetails = `-- name: GetMessageReceiptWithDetails :one
SELECT mr.message_id, mr.user_id, mr.delivered_at, mr.read_at, u.phone_number, u.display_name
FROM message_receipts mr
JOIN users u ON mr.user_id = u.id
WHERE mr.message_id = $1 AND mr.user_id = $2 LIMIT 1
`

type GetMessageReceiptWithDetailsParams struct {
	MessageID pgtype.UUID
	UserID    pgtype.UUID
}

type GetMessageReceiptWithDetailsRow struct {
	MessageID   pgtype.UUID
	UserID      pgtype.UUID
	DeliveredAt pgtype.Timestamptz
	ReadAt      pgtype.Timestamptz
	PhoneNumber string
	DisplayName pgtype.Text
}

func (q *Queries) GetMessageReceiptWithDetails(ctx context.Context, arg GetMessageReceiptWithDetailsParams) (GetMessageReceiptWithDetailsRow, error) {
	row := q.db.QueryRow(ctx, getMessageReceiptWithDetails, arg.MessageID, arg.UserID)
	var i GetMessageReceiptWithDetailsRow
	err := row.Scan(
		&i.MessageID,
		&i.UserID,
		&i.DeliveredAt,
		&i.ReadAt,
		&i.PhoneNumber,
		&i.DisplayName,
	)
	return i, err
}

const getUnreadMessageCount = `-- name: GetUnreadMessageCount :one
SELECT COUNT(*) FROM messages m
WHERE m.conversation_id = $1 
  AND m.sender_id != $2
  AND m.id NOT IN (
    SELECT message_id FROM message_receipts 
    WHERE user_id = $2 AND read_at IS NOT NULL
  )
`

type GetUnreadMessageCountParams struct {
	ConversationID pgtype.UUID
	SenderID       pgtype.UUID
}

func (q *Queries) GetUnreadMessageCount(ctx context.Context, arg GetUnreadMessageCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getUnreadMessageCount, arg.ConversationID, arg.SenderID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const listMessageReceipts = `-- name: ListMessageReceipts :many
SELECT message_id, user_id, delivered_at, read_at FROM message_receipts
WHERE message_id = $1
ORDER BY delivered_at ASC, read_at ASC
`

func (q *Queries) ListMessageReceipts(ctx context.Context, messageID pgtype.UUID) ([]MessageReceipt, error) {
	rows, err := q.db.Query(ctx, listMessageReceipts, messageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MessageReceipt
	for rows.Next() {
		var i MessageReceipt
		if err := rows.Scan(
			&i.MessageID,
			&i.UserID,
			&i.DeliveredAt,
			&i.ReadAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMessageReceiptsWithDetails = `-- name: ListMessageReceiptsWithDetails :many
SELECT mr.message_id, mr.user_id, mr.delivered_at, mr.read_at, u.phone_number, u.display_name
FROM message_receipts mr
JOIN users u ON mr.user_id = u.id
WHERE mr.message_id = $1
ORDER BY mr.delivered_at ASC, mr.read_at ASC
`

type ListMessageReceiptsWithDetailsRow struct {
	MessageID   pgtype.UUID
	UserID      pgtype.UUID
	DeliveredAt pgtype.Timestamptz
	ReadAt      pgtype.Timestamptz
	PhoneNumber string
	DisplayName pgtype.Text
}

func (q *Queries) ListMessageReceiptsWithDetails(ctx context.Context, messageID pgtype.UUID) ([]ListMessageReceiptsWithDetailsRow, error) {
	rows, err := q.db.Query(ctx, listMessageReceiptsWithDetails, messageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMessageReceiptsWithDetailsRow
	for rows.Next() {
		var i ListMessageReceiptsWithDetailsRow
		if err := rows.Scan(
			&i.MessageID,
			&i.UserID,
			&i.DeliveredAt,
			&i.ReadAt,
			&i.PhoneNumber,
			&i.DisplayName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnreadMessages = `-- name: ListUnreadMessages :many
SELECT m.id, m.conversation_id, m.sender_id, m.content, m.message_type, m.reply_to_id, m.created_at, c.title as conversation_title
FROM messages m
JOIN conversations c ON m.conversation_id = c.id
WHERE m.id NOT IN (
  SELECT message_id FROM message_receipts 
  WHERE user_id = $1 AND read_at IS NOT NULL
) AND m.sender_id != $1
ORDER BY m.created_at DESC
`

type ListUnreadMessagesRow struct {
	ID                pgtype.UUID
	ConversationID    pgtype.UUID
	SenderID          pgtype.UUID
	Content           pgtype.Text
	MessageType       string
	ReplyToID         pgtype.UUID
	CreatedAt         pgtype.Timestamptz
	ConversationTitle pgtype.Text
}

func (q *Queries) ListUnreadMessages(ctx context.Context, userID pgtype.UUID) ([]ListUnreadMessagesRow, error) {
	rows, err := q.db.Query(ctx, listUnreadMessages, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUnreadMessagesRow
	for rows.Next() {
		var i ListUnreadMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.ConversationID,
			&i.SenderID,
			&i.Content,
			&i.MessageType,
			&i.ReplyToID,
			&i.CreatedAt,
			&i.ConversationTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserMessageReceipts = `-- name: ListUserMessageReceipts :many
SELECT mr.message_id, mr.user_id, mr.delivered_at, mr.read_at, m.content as message_content, m.created_at as message_created_at
FROM message_receipts mr
JOIN messages m ON mr.message_id = m.id
WHERE mr.user_id = $1
ORDER BY m.created_at DESC
`

type ListUserMessageReceiptsRow struct {
	MessageID        pgtype.UUID
	UserID           pgtype.UUID
	DeliveredAt      pgtype.Timestamptz
	ReadAt           pgtype.Timestamptz
	MessageContent   pgtype.Text
	MessageCreatedAt pgtype.Timestamptz
}

func (q *Queries) ListUserMessageReceipts(ctx context.Context, userID pgtype.UUID) ([]ListUserMessageReceiptsRow, error) {
	rows, err := q.db.Query(ctx, listUserMessageReceipts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUserMessageReceiptsRow
	for rows.Next() {
		var i ListUserMessageReceiptsRow
		if err := rows.Scan(
			&i.MessageID,
			&i.UserID,
			&i.DeliveredAt,
			&i.ReadAt,
			&i.MessageContent,
			&i.MessageCreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markMessageAsDelivered = `-- name: MarkMessageAsDelivered :one
INSERT INTO message_receipts (
  message_id, user_id, delivered_at
) VALUES (
  $1, $2, NOW()
)
ON CONFLICT (message_id, user_id) 
DO UPDATE SET delivered_at = NOW()
RETURNING message_id, user_id, delivered_at, read_at
`

type MarkMessageAsDeliveredParams struct {
	MessageID pgtype.UUID
	UserID    pgtype.UUID
}

func (q *Queries) MarkMessageAsDelivered(ctx context.Context, arg MarkMessageAsDeliveredParams) (MessageReceipt, error) {
	row := q.db.QueryRow(ctx, markMessageAsDelivered, arg.MessageID, arg.UserID)
	var i MessageReceipt
	err := row.Scan(
		&i.MessageID,
		&i.UserID,
		&i.DeliveredAt,
		&i.ReadAt,
	)
	return i, err
}

const markMessageAsRead = `-- name: MarkMessageAsRead :one
INSERT INTO message_receipts (
  message_id, user_id, delivered_at, read_at
) VALUES (
  $1, $2, NOW(), NOW()
)
ON CONFLICT (message_id, user_id) 
DO UPDATE SET read_at = NOW()
RETURNING message_id, user_id, delivered_at, read_at
`

type MarkMessageAsReadParams struct {
	MessageID pgtype.UUID
	UserID    pgtype.UUID
}

func (q *Queries) MarkMessageAsRead(ctx context.Context, arg MarkMessageAsReadParams) (MessageReceipt, error) {
	row := q.db.QueryRow(ctx, markMessageAsRead, arg.MessageID, arg.UserID)
	var i MessageReceipt
	err := row.Scan(
		&i.MessageID,
		&i.UserID,
		&i.DeliveredAt,
		&i.ReadAt,
	)
	return i, err
}

const updateMessageReceipt = `-- name: UpdateMessageReceipt :one
UPDATE message_receipts
SET delivered_at = $3,
    read_at = $4
WHERE message_id = $1 AND user_id = $2
RETURNING message_id, user_id, delivered_at, read_at
`

type UpdateMessageReceiptParams struct {
	MessageID   pgtype.UUID
	UserID      pgtype.UUID
	DeliveredAt pgtype.Timestamptz
	ReadAt      pgtype.Timestamptz
}

func (q *Queries) UpdateMessageReceipt(ctx context.Context, arg UpdateMessageReceiptParams) (MessageReceipt, error) {
	row := q.db.QueryRow(ctx, updateMessageReceipt,
		arg.MessageID,
		arg.UserID,
		arg.DeliveredAt,
		arg.ReadAt,
	)
	var i MessageReceipt
	err := row.Scan(
		&i.MessageID,
		&i.UserID,
		&i.DeliveredAt,
		&i.ReadAt,
	)
	return i, err
}
