// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: contacts.sql

package storage

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addContact = `-- name: AddContact :one
INSERT INTO contacts (
  user_id, contact_id, contact_name
) VALUES (
  $1, $2, $3
)
RETURNING user_id, contact_id, contact_name
`

type AddContactParams struct {
	UserID      pgtype.UUID
	ContactID   pgtype.UUID
	ContactName pgtype.Text
}

func (q *Queries) AddContact(ctx context.Context, arg AddContactParams) (Contact, error) {
	row := q.db.QueryRow(ctx, addContact, arg.UserID, arg.ContactID, arg.ContactName)
	var i Contact
	err := row.Scan(&i.UserID, &i.ContactID, &i.ContactName)
	return i, err
}

const countUserContacts = `-- name: CountUserContacts :one
SELECT COUNT(*) FROM contacts
WHERE user_id = $1
`

func (q *Queries) CountUserContacts(ctx context.Context, userID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countUserContacts, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCommonContacts = `-- name: GetCommonContacts :many
SELECT c.user_id, c.contact_id, c.contact_name, u.phone_number as contact_phone, u.display_name as contact_display_name
FROM contacts c
JOIN users u ON c.contact_id = u.id
WHERE c.user_id = $1
  AND c.contact_id IN (
    SELECT contact_id FROM contacts c2 WHERE c2.user_id = $2
  )
ORDER BY c.contact_name ASC
`

type GetCommonContactsParams struct {
	UserID   pgtype.UUID
	UserID_2 pgtype.UUID
}

type GetCommonContactsRow struct {
	UserID             pgtype.UUID
	ContactID          pgtype.UUID
	ContactName        pgtype.Text
	ContactPhone       string
	ContactDisplayName pgtype.Text
}

func (q *Queries) GetCommonContacts(ctx context.Context, arg GetCommonContactsParams) ([]GetCommonContactsRow, error) {
	rows, err := q.db.Query(ctx, getCommonContacts, arg.UserID, arg.UserID_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCommonContactsRow
	for rows.Next() {
		var i GetCommonContactsRow
		if err := rows.Scan(
			&i.UserID,
			&i.ContactID,
			&i.ContactName,
			&i.ContactPhone,
			&i.ContactDisplayName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getContact = `-- name: GetContact :one
SELECT user_id, contact_id, contact_name FROM contacts
WHERE user_id = $1 AND contact_id = $2 LIMIT 1
`

type GetContactParams struct {
	UserID    pgtype.UUID
	ContactID pgtype.UUID
}

func (q *Queries) GetContact(ctx context.Context, arg GetContactParams) (Contact, error) {
	row := q.db.QueryRow(ctx, getContact, arg.UserID, arg.ContactID)
	var i Contact
	err := row.Scan(&i.UserID, &i.ContactID, &i.ContactName)
	return i, err
}

const getContactWithDetails = `-- name: GetContactWithDetails :one
SELECT c.user_id, c.contact_id, c.contact_name, u.phone_number as contact_phone, u.display_name as contact_display_name
FROM contacts c
JOIN users u ON c.contact_id = u.id
WHERE c.user_id = $1 AND c.contact_id = $2 LIMIT 1
`

type GetContactWithDetailsParams struct {
	UserID    pgtype.UUID
	ContactID pgtype.UUID
}

type GetContactWithDetailsRow struct {
	UserID             pgtype.UUID
	ContactID          pgtype.UUID
	ContactName        pgtype.Text
	ContactPhone       string
	ContactDisplayName pgtype.Text
}

func (q *Queries) GetContactWithDetails(ctx context.Context, arg GetContactWithDetailsParams) (GetContactWithDetailsRow, error) {
	row := q.db.QueryRow(ctx, getContactWithDetails, arg.UserID, arg.ContactID)
	var i GetContactWithDetailsRow
	err := row.Scan(
		&i.UserID,
		&i.ContactID,
		&i.ContactName,
		&i.ContactPhone,
		&i.ContactDisplayName,
	)
	return i, err
}

const getMutualContacts = `-- name: GetMutualContacts :many
SELECT c1.contact_id, c1.contact_name as user1_name, c2.contact_name as user2_name,
       u.phone_number, u.display_name
FROM contacts c1
JOIN contacts c2 ON c1.contact_id = c2.user_id AND c2.contact_id = c1.user_id
JOIN users u ON c1.contact_id = u.id
WHERE c1.user_id = $1
ORDER BY c1.contact_name ASC
`

type GetMutualContactsRow struct {
	ContactID   pgtype.UUID
	User1Name   pgtype.Text
	User2Name   pgtype.Text
	PhoneNumber string
	DisplayName pgtype.Text
}

func (q *Queries) GetMutualContacts(ctx context.Context, userID pgtype.UUID) ([]GetMutualContactsRow, error) {
	rows, err := q.db.Query(ctx, getMutualContacts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMutualContactsRow
	for rows.Next() {
		var i GetMutualContactsRow
		if err := rows.Scan(
			&i.ContactID,
			&i.User1Name,
			&i.User2Name,
			&i.PhoneNumber,
			&i.DisplayName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isUserContact = `-- name: IsUserContact :one
SELECT EXISTS(
  SELECT 1 FROM contacts
  WHERE user_id = $1 AND contact_id = $2
)
`

type IsUserContactParams struct {
	UserID    pgtype.UUID
	ContactID pgtype.UUID
}

func (q *Queries) IsUserContact(ctx context.Context, arg IsUserContactParams) (bool, error) {
	row := q.db.QueryRow(ctx, isUserContact, arg.UserID, arg.ContactID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const listContactSuggestions = `-- name: ListContactSuggestions :many
SELECT u.id, u.phone_number, u.display_name, u.about, u.created_at, 'mutual' as suggestion_type
FROM users u
WHERE u.id IN (
  SELECT contact_id FROM contacts c2 WHERE c2.user_id IN (
    SELECT contact_id FROM contacts c3 WHERE c3.user_id = $1
  ) AND c2.contact_id != $1
  AND c2.contact_id NOT IN (SELECT contact_id FROM contacts c4 WHERE c4.user_id = $1)
)
LIMIT 10
`

type ListContactSuggestionsRow struct {
	ID             pgtype.UUID
	PhoneNumber    string
	DisplayName    pgtype.Text
	About          pgtype.Text
	CreatedAt      pgtype.Timestamptz
	SuggestionType string
}

func (q *Queries) ListContactSuggestions(ctx context.Context, userID pgtype.UUID) ([]ListContactSuggestionsRow, error) {
	rows, err := q.db.Query(ctx, listContactSuggestions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListContactSuggestionsRow
	for rows.Next() {
		var i ListContactSuggestionsRow
		if err := rows.Scan(
			&i.ID,
			&i.PhoneNumber,
			&i.DisplayName,
			&i.About,
			&i.CreatedAt,
			&i.SuggestionType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContactUsers = `-- name: ListContactUsers :many
SELECT user_id, contact_id, contact_name FROM contacts
WHERE contact_id = $1
ORDER BY contact_name ASC
`

func (q *Queries) ListContactUsers(ctx context.Context, contactID pgtype.UUID) ([]Contact, error) {
	rows, err := q.db.Query(ctx, listContactUsers, contactID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Contact
	for rows.Next() {
		var i Contact
		if err := rows.Scan(&i.UserID, &i.ContactID, &i.ContactName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserContacts = `-- name: ListUserContacts :many
SELECT user_id, contact_id, contact_name FROM contacts
WHERE user_id = $1
ORDER BY contact_name ASC
`

func (q *Queries) ListUserContacts(ctx context.Context, userID pgtype.UUID) ([]Contact, error) {
	rows, err := q.db.Query(ctx, listUserContacts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Contact
	for rows.Next() {
		var i Contact
		if err := rows.Scan(&i.UserID, &i.ContactID, &i.ContactName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserContactsWithDetails = `-- name: ListUserContactsWithDetails :many
SELECT c.user_id, c.contact_id, c.contact_name, u.phone_number as contact_phone, u.display_name as contact_display_name, u.about as contact_about
FROM contacts c
JOIN users u ON c.contact_id = u.id
WHERE c.user_id = $1
ORDER BY c.contact_name ASC
`

type ListUserContactsWithDetailsRow struct {
	UserID             pgtype.UUID
	ContactID          pgtype.UUID
	ContactName        pgtype.Text
	ContactPhone       string
	ContactDisplayName pgtype.Text
	ContactAbout       pgtype.Text
}

func (q *Queries) ListUserContactsWithDetails(ctx context.Context, userID pgtype.UUID) ([]ListUserContactsWithDetailsRow, error) {
	rows, err := q.db.Query(ctx, listUserContactsWithDetails, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUserContactsWithDetailsRow
	for rows.Next() {
		var i ListUserContactsWithDetailsRow
		if err := rows.Scan(
			&i.UserID,
			&i.ContactID,
			&i.ContactName,
			&i.ContactPhone,
			&i.ContactDisplayName,
			&i.ContactAbout,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeAllUserContacts = `-- name: RemoveAllUserContacts :exec
DELETE FROM contacts
WHERE user_id = $1
`

func (q *Queries) RemoveAllUserContacts(ctx context.Context, userID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, removeAllUserContacts, userID)
	return err
}

const removeContact = `-- name: RemoveContact :exec
DELETE FROM contacts
WHERE user_id = $1 AND contact_id = $2
`

type RemoveContactParams struct {
	UserID    pgtype.UUID
	ContactID pgtype.UUID
}

func (q *Queries) RemoveContact(ctx context.Context, arg RemoveContactParams) error {
	_, err := q.db.Exec(ctx, removeContact, arg.UserID, arg.ContactID)
	return err
}

const searchUserContacts = `-- name: SearchUserContacts :many
SELECT c.user_id, c.contact_id, c.contact_name, u.phone_number as contact_phone, u.display_name as contact_display_name
FROM contacts c
JOIN users u ON c.contact_id = u.id
WHERE c.user_id = $1 
  AND (c.contact_name ILIKE '%' || $2 || '%' 
       OR u.phone_number LIKE $2 || '%'
       OR u.display_name ILIKE '%' || $2 || '%')
ORDER BY c.contact_name ASC
LIMIT 20
`

type SearchUserContactsParams struct {
	UserID  pgtype.UUID
	Column2 pgtype.Text
}

type SearchUserContactsRow struct {
	UserID             pgtype.UUID
	ContactID          pgtype.UUID
	ContactName        pgtype.Text
	ContactPhone       string
	ContactDisplayName pgtype.Text
}

func (q *Queries) SearchUserContacts(ctx context.Context, arg SearchUserContactsParams) ([]SearchUserContactsRow, error) {
	rows, err := q.db.Query(ctx, searchUserContacts, arg.UserID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchUserContactsRow
	for rows.Next() {
		var i SearchUserContactsRow
		if err := rows.Scan(
			&i.UserID,
			&i.ContactID,
			&i.ContactName,
			&i.ContactPhone,
			&i.ContactDisplayName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateContactName = `-- name: UpdateContactName :one
UPDATE contacts
SET contact_name = $3
WHERE user_id = $1 AND contact_id = $2
RETURNING user_id, contact_id, contact_name
`

type UpdateContactNameParams struct {
	UserID      pgtype.UUID
	ContactID   pgtype.UUID
	ContactName pgtype.Text
}

func (q *Queries) UpdateContactName(ctx context.Context, arg UpdateContactNameParams) (Contact, error) {
	row := q.db.QueryRow(ctx, updateContactName, arg.UserID, arg.ContactID, arg.ContactName)
	var i Contact
	err := row.Scan(&i.UserID, &i.ContactID, &i.ContactName)
	return i, err
}
