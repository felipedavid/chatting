// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: conversation_participants.sql

package storage

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addConversationParticipant = `-- name: AddConversationParticipant :one
INSERT INTO conversation_participants (
  conversation_id, user_id, role
) VALUES (
  $1, $2, $3
)
RETURNING conversation_id, user_id, role, joined_at
`

type AddConversationParticipantParams struct {
	ConversationID pgtype.UUID
	UserID         pgtype.UUID
	Role           pgtype.Text
}

func (q *Queries) AddConversationParticipant(ctx context.Context, arg AddConversationParticipantParams) (ConversationParticipant, error) {
	row := q.db.QueryRow(ctx, addConversationParticipant, arg.ConversationID, arg.UserID, arg.Role)
	var i ConversationParticipant
	err := row.Scan(
		&i.ConversationID,
		&i.UserID,
		&i.Role,
		&i.JoinedAt,
	)
	return i, err
}

const countConversationParticipants = `-- name: CountConversationParticipants :one
SELECT COUNT(*) FROM conversation_participants
WHERE conversation_id = $1
`

func (q *Queries) CountConversationParticipants(ctx context.Context, conversationID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countConversationParticipants, conversationID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getConversationParticipant = `-- name: GetConversationParticipant :one
SELECT conversation_id, user_id, role, joined_at FROM conversation_participants
WHERE conversation_id = $1 AND user_id = $2 LIMIT 1
`

type GetConversationParticipantParams struct {
	ConversationID pgtype.UUID
	UserID         pgtype.UUID
}

func (q *Queries) GetConversationParticipant(ctx context.Context, arg GetConversationParticipantParams) (ConversationParticipant, error) {
	row := q.db.QueryRow(ctx, getConversationParticipant, arg.ConversationID, arg.UserID)
	var i ConversationParticipant
	err := row.Scan(
		&i.ConversationID,
		&i.UserID,
		&i.Role,
		&i.JoinedAt,
	)
	return i, err
}

const getConversationParticipantWithDetails = `-- name: GetConversationParticipantWithDetails :one
SELECT cp.conversation_id, cp.user_id, cp.role, cp.joined_at, u.phone_number, u.display_name
FROM conversation_participants cp
JOIN users u ON cp.user_id = u.id
WHERE cp.conversation_id = $1 AND cp.user_id = $2 LIMIT 1
`

type GetConversationParticipantWithDetailsParams struct {
	ConversationID pgtype.UUID
	UserID         pgtype.UUID
}

type GetConversationParticipantWithDetailsRow struct {
	ConversationID pgtype.UUID
	UserID         pgtype.UUID
	Role           pgtype.Text
	JoinedAt       pgtype.Timestamptz
	PhoneNumber    string
	DisplayName    pgtype.Text
}

func (q *Queries) GetConversationParticipantWithDetails(ctx context.Context, arg GetConversationParticipantWithDetailsParams) (GetConversationParticipantWithDetailsRow, error) {
	row := q.db.QueryRow(ctx, getConversationParticipantWithDetails, arg.ConversationID, arg.UserID)
	var i GetConversationParticipantWithDetailsRow
	err := row.Scan(
		&i.ConversationID,
		&i.UserID,
		&i.Role,
		&i.JoinedAt,
		&i.PhoneNumber,
		&i.DisplayName,
	)
	return i, err
}

const isUserInConversation = `-- name: IsUserInConversation :one
SELECT EXISTS(
  SELECT 1 FROM conversation_participants
  WHERE conversation_id = $1 AND user_id = $2
)
`

type IsUserInConversationParams struct {
	ConversationID pgtype.UUID
	UserID         pgtype.UUID
}

func (q *Queries) IsUserInConversation(ctx context.Context, arg IsUserInConversationParams) (bool, error) {
	row := q.db.QueryRow(ctx, isUserInConversation, arg.ConversationID, arg.UserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const listConversationParticipants = `-- name: ListConversationParticipants :many
SELECT conversation_id, user_id, role, joined_at FROM conversation_participants
WHERE conversation_id = $1
ORDER BY joined_at ASC
`

func (q *Queries) ListConversationParticipants(ctx context.Context, conversationID pgtype.UUID) ([]ConversationParticipant, error) {
	rows, err := q.db.Query(ctx, listConversationParticipants, conversationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ConversationParticipant
	for rows.Next() {
		var i ConversationParticipant
		if err := rows.Scan(
			&i.ConversationID,
			&i.UserID,
			&i.Role,
			&i.JoinedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listConversationParticipantsWithDetails = `-- name: ListConversationParticipantsWithDetails :many
SELECT cp.conversation_id, cp.user_id, cp.role, cp.joined_at, u.phone_number, u.display_name
FROM conversation_participants cp
JOIN users u ON cp.user_id = u.id
WHERE cp.conversation_id = $1
ORDER BY cp.joined_at ASC
`

type ListConversationParticipantsWithDetailsRow struct {
	ConversationID pgtype.UUID
	UserID         pgtype.UUID
	Role           pgtype.Text
	JoinedAt       pgtype.Timestamptz
	PhoneNumber    string
	DisplayName    pgtype.Text
}

func (q *Queries) ListConversationParticipantsWithDetails(ctx context.Context, conversationID pgtype.UUID) ([]ListConversationParticipantsWithDetailsRow, error) {
	rows, err := q.db.Query(ctx, listConversationParticipantsWithDetails, conversationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListConversationParticipantsWithDetailsRow
	for rows.Next() {
		var i ListConversationParticipantsWithDetailsRow
		if err := rows.Scan(
			&i.ConversationID,
			&i.UserID,
			&i.Role,
			&i.JoinedAt,
			&i.PhoneNumber,
			&i.DisplayName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserConversations = `-- name: ListUserConversations :many
SELECT cp.conversation_id, cp.user_id, cp.role, cp.joined_at, c.title, c.is_group, c.created_at as conversation_created_at
FROM conversation_participants cp
JOIN conversations c ON cp.conversation_id = c.id
WHERE cp.user_id = $1
ORDER BY cp.joined_at DESC
`

type ListUserConversationsRow struct {
	ConversationID        pgtype.UUID
	UserID                pgtype.UUID
	Role                  pgtype.Text
	JoinedAt              pgtype.Timestamptz
	Title                 pgtype.Text
	IsGroup               bool
	ConversationCreatedAt pgtype.Timestamptz
}

func (q *Queries) ListUserConversations(ctx context.Context, userID pgtype.UUID) ([]ListUserConversationsRow, error) {
	rows, err := q.db.Query(ctx, listUserConversations, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUserConversationsRow
	for rows.Next() {
		var i ListUserConversationsRow
		if err := rows.Scan(
			&i.ConversationID,
			&i.UserID,
			&i.Role,
			&i.JoinedAt,
			&i.Title,
			&i.IsGroup,
			&i.ConversationCreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserConversationsWithLastMessage = `-- name: ListUserConversationsWithLastMessage :many
SELECT cp.conversation_id, cp.user_id, cp.role, cp.joined_at, c.title, c.is_group, c.created_at as conversation_created_at,
       m.content as last_message_content, m.created_at as last_message_at
FROM conversation_participants cp
JOIN conversations c ON cp.conversation_id = c.id
LEFT JOIN messages m ON m.conversation_id = c.id
WHERE cp.user_id = $1
  AND m.created_at = (
    SELECT MAX(created_at) 
    FROM messages 
    WHERE conversation_id = c.id
  )
ORDER BY m.created_at DESC
`

type ListUserConversationsWithLastMessageRow struct {
	ConversationID        pgtype.UUID
	UserID                pgtype.UUID
	Role                  pgtype.Text
	JoinedAt              pgtype.Timestamptz
	Title                 pgtype.Text
	IsGroup               bool
	ConversationCreatedAt pgtype.Timestamptz
	LastMessageContent    pgtype.Text
	LastMessageAt         pgtype.Timestamptz
}

func (q *Queries) ListUserConversationsWithLastMessage(ctx context.Context, userID pgtype.UUID) ([]ListUserConversationsWithLastMessageRow, error) {
	rows, err := q.db.Query(ctx, listUserConversationsWithLastMessage, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUserConversationsWithLastMessageRow
	for rows.Next() {
		var i ListUserConversationsWithLastMessageRow
		if err := rows.Scan(
			&i.ConversationID,
			&i.UserID,
			&i.Role,
			&i.JoinedAt,
			&i.Title,
			&i.IsGroup,
			&i.ConversationCreatedAt,
			&i.LastMessageContent,
			&i.LastMessageAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeAllConversationParticipants = `-- name: RemoveAllConversationParticipants :exec
DELETE FROM conversation_participants
WHERE conversation_id = $1
`

func (q *Queries) RemoveAllConversationParticipants(ctx context.Context, conversationID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, removeAllConversationParticipants, conversationID)
	return err
}

const removeConversationParticipant = `-- name: RemoveConversationParticipant :exec
DELETE FROM conversation_participants
WHERE conversation_id = $1 AND user_id = $2
`

type RemoveConversationParticipantParams struct {
	ConversationID pgtype.UUID
	UserID         pgtype.UUID
}

func (q *Queries) RemoveConversationParticipant(ctx context.Context, arg RemoveConversationParticipantParams) error {
	_, err := q.db.Exec(ctx, removeConversationParticipant, arg.ConversationID, arg.UserID)
	return err
}

const updateParticipantRole = `-- name: UpdateParticipantRole :one
UPDATE conversation_participants
SET role = $3
WHERE conversation_id = $1 AND user_id = $2
RETURNING conversation_id, user_id, role, joined_at
`

type UpdateParticipantRoleParams struct {
	ConversationID pgtype.UUID
	UserID         pgtype.UUID
	Role           pgtype.Text
}

func (q *Queries) UpdateParticipantRole(ctx context.Context, arg UpdateParticipantRoleParams) (ConversationParticipant, error) {
	row := q.db.QueryRow(ctx, updateParticipantRole, arg.ConversationID, arg.UserID, arg.Role)
	var i ConversationParticipant
	err := row.Scan(
		&i.ConversationID,
		&i.UserID,
		&i.Role,
		&i.JoinedAt,
	)
	return i, err
}
