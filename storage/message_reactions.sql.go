// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: message_reactions.sql

package storage

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addMessageReaction = `-- name: AddMessageReaction :one
INSERT INTO message_reactions (
  message_id, user_id, reaction
) VALUES (
  $1, $2, $3
)
RETURNING message_id, user_id, reaction, reacted_at
`

type AddMessageReactionParams struct {
	MessageID pgtype.UUID
	UserID    pgtype.UUID
	Reaction  string
}

func (q *Queries) AddMessageReaction(ctx context.Context, arg AddMessageReactionParams) (MessageReaction, error) {
	row := q.db.QueryRow(ctx, addMessageReaction, arg.MessageID, arg.UserID, arg.Reaction)
	var i MessageReaction
	err := row.Scan(
		&i.MessageID,
		&i.UserID,
		&i.Reaction,
		&i.ReactedAt,
	)
	return i, err
}

const countMessageReactions = `-- name: CountMessageReactions :one
SELECT COUNT(*) FROM message_reactions
WHERE message_id = $1
`

func (q *Queries) CountMessageReactions(ctx context.Context, messageID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countMessageReactions, messageID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMessageReactionsByType = `-- name: CountMessageReactionsByType :one
SELECT COUNT(*) FROM message_reactions
WHERE message_id = $1 AND reaction = $2
`

type CountMessageReactionsByTypeParams struct {
	MessageID pgtype.UUID
	Reaction  string
}

func (q *Queries) CountMessageReactionsByType(ctx context.Context, arg CountMessageReactionsByTypeParams) (int64, error) {
	row := q.db.QueryRow(ctx, countMessageReactionsByType, arg.MessageID, arg.Reaction)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getMessageReaction = `-- name: GetMessageReaction :one
SELECT message_id, user_id, reaction, reacted_at FROM message_reactions
WHERE message_id = $1 AND user_id = $2 LIMIT 1
`

type GetMessageReactionParams struct {
	MessageID pgtype.UUID
	UserID    pgtype.UUID
}

func (q *Queries) GetMessageReaction(ctx context.Context, arg GetMessageReactionParams) (MessageReaction, error) {
	row := q.db.QueryRow(ctx, getMessageReaction, arg.MessageID, arg.UserID)
	var i MessageReaction
	err := row.Scan(
		&i.MessageID,
		&i.UserID,
		&i.Reaction,
		&i.ReactedAt,
	)
	return i, err
}

const getMessageReactionSummary = `-- name: GetMessageReactionSummary :many
SELECT reaction, COUNT(*) as count
FROM message_reactions
WHERE message_id = $1
GROUP BY reaction
ORDER BY count DESC
`

type GetMessageReactionSummaryRow struct {
	Reaction string
	Count    int64
}

func (q *Queries) GetMessageReactionSummary(ctx context.Context, messageID pgtype.UUID) ([]GetMessageReactionSummaryRow, error) {
	rows, err := q.db.Query(ctx, getMessageReactionSummary, messageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMessageReactionSummaryRow
	for rows.Next() {
		var i GetMessageReactionSummaryRow
		if err := rows.Scan(&i.Reaction, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMessageReactionWithDetails = `-- name: GetMessageReactionWithDetails :one
SELECT mr.message_id, mr.user_id, mr.reaction, mr.reacted_at, u.phone_number, u.display_name
FROM message_reactions mr
JOIN users u ON mr.user_id = u.id
WHERE mr.message_id = $1 AND mr.user_id = $2 LIMIT 1
`

type GetMessageReactionWithDetailsParams struct {
	MessageID pgtype.UUID
	UserID    pgtype.UUID
}

type GetMessageReactionWithDetailsRow struct {
	MessageID   pgtype.UUID
	UserID      pgtype.UUID
	Reaction    string
	ReactedAt   pgtype.Timestamptz
	PhoneNumber string
	DisplayName pgtype.Text
}

func (q *Queries) GetMessageReactionWithDetails(ctx context.Context, arg GetMessageReactionWithDetailsParams) (GetMessageReactionWithDetailsRow, error) {
	row := q.db.QueryRow(ctx, getMessageReactionWithDetails, arg.MessageID, arg.UserID)
	var i GetMessageReactionWithDetailsRow
	err := row.Scan(
		&i.MessageID,
		&i.UserID,
		&i.Reaction,
		&i.ReactedAt,
		&i.PhoneNumber,
		&i.DisplayName,
	)
	return i, err
}

const getUserReactionOnMessage = `-- name: GetUserReactionOnMessage :one
SELECT reaction FROM message_reactions
WHERE message_id = $1 AND user_id = $2 LIMIT 1
`

type GetUserReactionOnMessageParams struct {
	MessageID pgtype.UUID
	UserID    pgtype.UUID
}

func (q *Queries) GetUserReactionOnMessage(ctx context.Context, arg GetUserReactionOnMessageParams) (string, error) {
	row := q.db.QueryRow(ctx, getUserReactionOnMessage, arg.MessageID, arg.UserID)
	var reaction string
	err := row.Scan(&reaction)
	return reaction, err
}

const hasUserReactedToMessage = `-- name: HasUserReactedToMessage :one
SELECT EXISTS(
  SELECT 1 FROM message_reactions
  WHERE message_id = $1 AND user_id = $2
)
`

type HasUserReactedToMessageParams struct {
	MessageID pgtype.UUID
	UserID    pgtype.UUID
}

func (q *Queries) HasUserReactedToMessage(ctx context.Context, arg HasUserReactedToMessageParams) (bool, error) {
	row := q.db.QueryRow(ctx, hasUserReactedToMessage, arg.MessageID, arg.UserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const listMessageReactions = `-- name: ListMessageReactions :many
SELECT message_id, user_id, reaction, reacted_at FROM message_reactions
WHERE message_id = $1
ORDER BY reacted_at ASC
`

func (q *Queries) ListMessageReactions(ctx context.Context, messageID pgtype.UUID) ([]MessageReaction, error) {
	rows, err := q.db.Query(ctx, listMessageReactions, messageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MessageReaction
	for rows.Next() {
		var i MessageReaction
		if err := rows.Scan(
			&i.MessageID,
			&i.UserID,
			&i.Reaction,
			&i.ReactedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMessageReactionsWithDetails = `-- name: ListMessageReactionsWithDetails :many
SELECT mr.message_id, mr.user_id, mr.reaction, mr.reacted_at, u.phone_number, u.display_name
FROM message_reactions mr
JOIN users u ON mr.user_id = u.id
WHERE mr.message_id = $1
ORDER BY mr.reacted_at ASC
`

type ListMessageReactionsWithDetailsRow struct {
	MessageID   pgtype.UUID
	UserID      pgtype.UUID
	Reaction    string
	ReactedAt   pgtype.Timestamptz
	PhoneNumber string
	DisplayName pgtype.Text
}

func (q *Queries) ListMessageReactionsWithDetails(ctx context.Context, messageID pgtype.UUID) ([]ListMessageReactionsWithDetailsRow, error) {
	rows, err := q.db.Query(ctx, listMessageReactionsWithDetails, messageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMessageReactionsWithDetailsRow
	for rows.Next() {
		var i ListMessageReactionsWithDetailsRow
		if err := rows.Scan(
			&i.MessageID,
			&i.UserID,
			&i.Reaction,
			&i.ReactedAt,
			&i.PhoneNumber,
			&i.DisplayName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMessagesByReaction = `-- name: ListMessagesByReaction :many
SELECT DISTINCT m.id, m.conversation_id, m.sender_id, m.content, m.message_type, m.reply_to_id, m.created_at, c.title as conversation_title
FROM messages m
JOIN conversations c ON m.conversation_id = c.id
JOIN message_reactions mr ON m.id = mr.message_id
WHERE mr.reaction = $1
ORDER BY m.created_at DESC
LIMIT 50
`

type ListMessagesByReactionRow struct {
	ID                pgtype.UUID
	ConversationID    pgtype.UUID
	SenderID          pgtype.UUID
	Content           pgtype.Text
	MessageType       string
	ReplyToID         pgtype.UUID
	CreatedAt         pgtype.Timestamptz
	ConversationTitle pgtype.Text
}

func (q *Queries) ListMessagesByReaction(ctx context.Context, reaction string) ([]ListMessagesByReactionRow, error) {
	rows, err := q.db.Query(ctx, listMessagesByReaction, reaction)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMessagesByReactionRow
	for rows.Next() {
		var i ListMessagesByReactionRow
		if err := rows.Scan(
			&i.ID,
			&i.ConversationID,
			&i.SenderID,
			&i.Content,
			&i.MessageType,
			&i.ReplyToID,
			&i.CreatedAt,
			&i.ConversationTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserReactions = `-- name: ListUserReactions :many
SELECT mr.message_id, mr.user_id, mr.reaction, mr.reacted_at, m.content as message_content, c.title as conversation_title
FROM message_reactions mr
JOIN messages m ON mr.message_id = m.id
JOIN conversations c ON m.conversation_id = c.id
WHERE mr.user_id = $1
ORDER BY mr.reacted_at DESC
`

type ListUserReactionsRow struct {
	MessageID         pgtype.UUID
	UserID            pgtype.UUID
	Reaction          string
	ReactedAt         pgtype.Timestamptz
	MessageContent    pgtype.Text
	ConversationTitle pgtype.Text
}

func (q *Queries) ListUserReactions(ctx context.Context, userID pgtype.UUID) ([]ListUserReactionsRow, error) {
	rows, err := q.db.Query(ctx, listUserReactions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUserReactionsRow
	for rows.Next() {
		var i ListUserReactionsRow
		if err := rows.Scan(
			&i.MessageID,
			&i.UserID,
			&i.Reaction,
			&i.ReactedAt,
			&i.MessageContent,
			&i.ConversationTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeAllMessageReactions = `-- name: RemoveAllMessageReactions :exec
DELETE FROM message_reactions
WHERE message_id = $1
`

func (q *Queries) RemoveAllMessageReactions(ctx context.Context, messageID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, removeAllMessageReactions, messageID)
	return err
}

const removeMessageReaction = `-- name: RemoveMessageReaction :exec
DELETE FROM message_reactions
WHERE message_id = $1 AND user_id = $2
`

type RemoveMessageReactionParams struct {
	MessageID pgtype.UUID
	UserID    pgtype.UUID
}

func (q *Queries) RemoveMessageReaction(ctx context.Context, arg RemoveMessageReactionParams) error {
	_, err := q.db.Exec(ctx, removeMessageReaction, arg.MessageID, arg.UserID)
	return err
}

const updateMessageReaction = `-- name: UpdateMessageReaction :one
UPDATE message_reactions
SET reaction = $3,
    reacted_at = NOW()
WHERE message_id = $1 AND user_id = $2
RETURNING message_id, user_id, reaction, reacted_at
`

type UpdateMessageReactionParams struct {
	MessageID pgtype.UUID
	UserID    pgtype.UUID
	Reaction  string
}

func (q *Queries) UpdateMessageReaction(ctx context.Context, arg UpdateMessageReactionParams) (MessageReaction, error) {
	row := q.db.QueryRow(ctx, updateMessageReaction, arg.MessageID, arg.UserID, arg.Reaction)
	var i MessageReaction
	err := row.Scan(
		&i.MessageID,
		&i.UserID,
		&i.Reaction,
		&i.ReactedAt,
	)
	return i, err
}
