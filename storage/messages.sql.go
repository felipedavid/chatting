// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: messages.sql

package storage

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countConversationMessages = `-- name: CountConversationMessages :one
SELECT COUNT(*) FROM messages
WHERE conversation_id = $1
`

func (q *Queries) CountConversationMessages(ctx context.Context, conversationID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countConversationMessages, conversationID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUserMessages = `-- name: CountUserMessages :one
SELECT COUNT(*) FROM messages
WHERE sender_id = $1
`

func (q *Queries) CountUserMessages(ctx context.Context, senderID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countUserMessages, senderID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createMessage = `-- name: CreateMessage :one
INSERT INTO messages (
  conversation_id, sender_id, content, message_type, reply_to_id
) VALUES (
  $1, $2, $3, $4, $5
)
RETURNING id, conversation_id, sender_id, content, message_type, reply_to_id, created_at
`

type CreateMessageParams struct {
	ConversationID pgtype.UUID
	SenderID       pgtype.UUID
	Content        pgtype.Text
	MessageType    string
	ReplyToID      pgtype.UUID
}

func (q *Queries) CreateMessage(ctx context.Context, arg CreateMessageParams) (Message, error) {
	row := q.db.QueryRow(ctx, createMessage,
		arg.ConversationID,
		arg.SenderID,
		arg.Content,
		arg.MessageType,
		arg.ReplyToID,
	)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.ConversationID,
		&i.SenderID,
		&i.Content,
		&i.MessageType,
		&i.ReplyToID,
		&i.CreatedAt,
	)
	return i, err
}

const deleteConversationMessages = `-- name: DeleteConversationMessages :exec
DELETE FROM messages
WHERE conversation_id = $1
`

func (q *Queries) DeleteConversationMessages(ctx context.Context, conversationID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteConversationMessages, conversationID)
	return err
}

const deleteMessage = `-- name: DeleteMessage :exec
DELETE FROM messages
WHERE id = $1
`

func (q *Queries) DeleteMessage(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteMessage, id)
	return err
}

const getLatestConversationMessage = `-- name: GetLatestConversationMessage :one
SELECT id, conversation_id, sender_id, content, message_type, reply_to_id, created_at FROM messages
WHERE conversation_id = $1
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetLatestConversationMessage(ctx context.Context, conversationID pgtype.UUID) (Message, error) {
	row := q.db.QueryRow(ctx, getLatestConversationMessage, conversationID)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.ConversationID,
		&i.SenderID,
		&i.Content,
		&i.MessageType,
		&i.ReplyToID,
		&i.CreatedAt,
	)
	return i, err
}

const getMessage = `-- name: GetMessage :one
SELECT id, conversation_id, sender_id, content, message_type, reply_to_id, created_at FROM messages
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetMessage(ctx context.Context, id pgtype.UUID) (Message, error) {
	row := q.db.QueryRow(ctx, getMessage, id)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.ConversationID,
		&i.SenderID,
		&i.Content,
		&i.MessageType,
		&i.ReplyToID,
		&i.CreatedAt,
	)
	return i, err
}

const getMessageWithDetails = `-- name: GetMessageWithDetails :one
SELECT m.id, m.conversation_id, m.sender_id, m.content, m.message_type, m.reply_to_id, m.created_at, u.phone_number as sender_phone, u.display_name as sender_name
FROM messages m
LEFT JOIN users u ON m.sender_id = u.id
WHERE m.id = $1 LIMIT 1
`

type GetMessageWithDetailsRow struct {
	ID             pgtype.UUID
	ConversationID pgtype.UUID
	SenderID       pgtype.UUID
	Content        pgtype.Text
	MessageType    string
	ReplyToID      pgtype.UUID
	CreatedAt      pgtype.Timestamptz
	SenderPhone    pgtype.Text
	SenderName     pgtype.Text
}

func (q *Queries) GetMessageWithDetails(ctx context.Context, id pgtype.UUID) (GetMessageWithDetailsRow, error) {
	row := q.db.QueryRow(ctx, getMessageWithDetails, id)
	var i GetMessageWithDetailsRow
	err := row.Scan(
		&i.ID,
		&i.ConversationID,
		&i.SenderID,
		&i.Content,
		&i.MessageType,
		&i.ReplyToID,
		&i.CreatedAt,
		&i.SenderPhone,
		&i.SenderName,
	)
	return i, err
}

const getMessagesAfterTimestamp = `-- name: GetMessagesAfterTimestamp :many
SELECT id, conversation_id, sender_id, content, message_type, reply_to_id, created_at FROM messages
WHERE conversation_id = $1 AND created_at > $2
ORDER BY created_at ASC
`

type GetMessagesAfterTimestampParams struct {
	ConversationID pgtype.UUID
	CreatedAt      pgtype.Timestamptz
}

func (q *Queries) GetMessagesAfterTimestamp(ctx context.Context, arg GetMessagesAfterTimestampParams) ([]Message, error) {
	rows, err := q.db.Query(ctx, getMessagesAfterTimestamp, arg.ConversationID, arg.CreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Message
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.ConversationID,
			&i.SenderID,
			&i.Content,
			&i.MessageType,
			&i.ReplyToID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMessagesBeforeTimestamp = `-- name: GetMessagesBeforeTimestamp :many
SELECT id, conversation_id, sender_id, content, message_type, reply_to_id, created_at FROM messages
WHERE conversation_id = $1 AND created_at < $2
ORDER BY created_at DESC
LIMIT $3
`

type GetMessagesBeforeTimestampParams struct {
	ConversationID pgtype.UUID
	CreatedAt      pgtype.Timestamptz
	Limit          int32
}

func (q *Queries) GetMessagesBeforeTimestamp(ctx context.Context, arg GetMessagesBeforeTimestampParams) ([]Message, error) {
	rows, err := q.db.Query(ctx, getMessagesBeforeTimestamp, arg.ConversationID, arg.CreatedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Message
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.ConversationID,
			&i.SenderID,
			&i.Content,
			&i.MessageType,
			&i.ReplyToID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listConversationMessages = `-- name: ListConversationMessages :many
SELECT id, conversation_id, sender_id, content, message_type, reply_to_id, created_at FROM messages
WHERE conversation_id = $1
ORDER BY created_at ASC
`

func (q *Queries) ListConversationMessages(ctx context.Context, conversationID pgtype.UUID) ([]Message, error) {
	rows, err := q.db.Query(ctx, listConversationMessages, conversationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Message
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.ConversationID,
			&i.SenderID,
			&i.Content,
			&i.MessageType,
			&i.ReplyToID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listConversationMessagesPaginated = `-- name: ListConversationMessagesPaginated :many
SELECT id, conversation_id, sender_id, content, message_type, reply_to_id, created_at FROM messages
WHERE conversation_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListConversationMessagesPaginatedParams struct {
	ConversationID pgtype.UUID
	Limit          int32
	Offset         int32
}

func (q *Queries) ListConversationMessagesPaginated(ctx context.Context, arg ListConversationMessagesPaginatedParams) ([]Message, error) {
	rows, err := q.db.Query(ctx, listConversationMessagesPaginated, arg.ConversationID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Message
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.ConversationID,
			&i.SenderID,
			&i.Content,
			&i.MessageType,
			&i.ReplyToID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listConversationMessagesWithDetails = `-- name: ListConversationMessagesWithDetails :many
SELECT m.id, m.conversation_id, m.sender_id, m.content, m.message_type, m.reply_to_id, m.created_at, u.phone_number as sender_phone, u.display_name as sender_name
FROM messages m
LEFT JOIN users u ON m.sender_id = u.id
WHERE m.conversation_id = $1
ORDER BY m.created_at ASC
`

type ListConversationMessagesWithDetailsRow struct {
	ID             pgtype.UUID
	ConversationID pgtype.UUID
	SenderID       pgtype.UUID
	Content        pgtype.Text
	MessageType    string
	ReplyToID      pgtype.UUID
	CreatedAt      pgtype.Timestamptz
	SenderPhone    pgtype.Text
	SenderName     pgtype.Text
}

func (q *Queries) ListConversationMessagesWithDetails(ctx context.Context, conversationID pgtype.UUID) ([]ListConversationMessagesWithDetailsRow, error) {
	rows, err := q.db.Query(ctx, listConversationMessagesWithDetails, conversationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListConversationMessagesWithDetailsRow
	for rows.Next() {
		var i ListConversationMessagesWithDetailsRow
		if err := rows.Scan(
			&i.ID,
			&i.ConversationID,
			&i.SenderID,
			&i.Content,
			&i.MessageType,
			&i.ReplyToID,
			&i.CreatedAt,
			&i.SenderPhone,
			&i.SenderName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMessages = `-- name: ListMessages :many
SELECT id, conversation_id, sender_id, content, message_type, reply_to_id, created_at FROM messages
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListMessagesParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) ListMessages(ctx context.Context, arg ListMessagesParams) ([]Message, error) {
	rows, err := q.db.Query(ctx, listMessages, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Message
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.ConversationID,
			&i.SenderID,
			&i.Content,
			&i.MessageType,
			&i.ReplyToID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReplyMessages = `-- name: ListReplyMessages :many
SELECT id, conversation_id, sender_id, content, message_type, reply_to_id, created_at FROM messages
WHERE reply_to_id = $1
ORDER BY created_at ASC
`

func (q *Queries) ListReplyMessages(ctx context.Context, replyToID pgtype.UUID) ([]Message, error) {
	rows, err := q.db.Query(ctx, listReplyMessages, replyToID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Message
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.ConversationID,
			&i.SenderID,
			&i.Content,
			&i.MessageType,
			&i.ReplyToID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserMessages = `-- name: ListUserMessages :many
SELECT m.id, m.conversation_id, m.sender_id, m.content, m.message_type, m.reply_to_id, m.created_at, c.title as conversation_title, c.is_group
FROM messages m
JOIN conversations c ON m.conversation_id = c.id
WHERE m.sender_id = $1
ORDER BY m.created_at DESC
`

type ListUserMessagesRow struct {
	ID                pgtype.UUID
	ConversationID    pgtype.UUID
	SenderID          pgtype.UUID
	Content           pgtype.Text
	MessageType       string
	ReplyToID         pgtype.UUID
	CreatedAt         pgtype.Timestamptz
	ConversationTitle pgtype.Text
	IsGroup           bool
}

func (q *Queries) ListUserMessages(ctx context.Context, senderID pgtype.UUID) ([]ListUserMessagesRow, error) {
	rows, err := q.db.Query(ctx, listUserMessages, senderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUserMessagesRow
	for rows.Next() {
		var i ListUserMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.ConversationID,
			&i.SenderID,
			&i.Content,
			&i.MessageType,
			&i.ReplyToID,
			&i.CreatedAt,
			&i.ConversationTitle,
			&i.IsGroup,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchMessages = `-- name: SearchMessages :many
SELECT m.id, m.conversation_id, m.sender_id, m.content, m.message_type, m.reply_to_id, m.created_at, c.title as conversation_title
FROM messages m
JOIN conversations c ON m.conversation_id = c.id
WHERE m.content ILIKE '%' || $1 || '%'
ORDER BY m.created_at DESC
LIMIT 50
`

type SearchMessagesRow struct {
	ID                pgtype.UUID
	ConversationID    pgtype.UUID
	SenderID          pgtype.UUID
	Content           pgtype.Text
	MessageType       string
	ReplyToID         pgtype.UUID
	CreatedAt         pgtype.Timestamptz
	ConversationTitle pgtype.Text
}

func (q *Queries) SearchMessages(ctx context.Context, dollar_1 pgtype.Text) ([]SearchMessagesRow, error) {
	rows, err := q.db.Query(ctx, searchMessages, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchMessagesRow
	for rows.Next() {
		var i SearchMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.ConversationID,
			&i.SenderID,
			&i.Content,
			&i.MessageType,
			&i.ReplyToID,
			&i.CreatedAt,
			&i.ConversationTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMessageContent = `-- name: UpdateMessageContent :one
UPDATE messages
SET content = $2
WHERE id = $1
RETURNING id, conversation_id, sender_id, content, message_type, reply_to_id, created_at
`

type UpdateMessageContentParams struct {
	ID      pgtype.UUID
	Content pgtype.Text
}

func (q *Queries) UpdateMessageContent(ctx context.Context, arg UpdateMessageContentParams) (Message, error) {
	row := q.db.QueryRow(ctx, updateMessageContent, arg.ID, arg.Content)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.ConversationID,
		&i.SenderID,
		&i.Content,
		&i.MessageType,
		&i.ReplyToID,
		&i.CreatedAt,
	)
	return i, err
}
