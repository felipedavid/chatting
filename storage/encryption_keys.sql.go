// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: encryption_keys.sql

package storage

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countUserEncryptionKeys = `-- name: CountUserEncryptionKeys :one
SELECT COUNT(*) FROM encryption_keys ek
JOIN user_devices ud ON ek.device_id = ud.id
WHERE ud.user_id = $1
`

func (q *Queries) CountUserEncryptionKeys(ctx context.Context, userID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countUserEncryptionKeys, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createEncryptionKey = `-- name: CreateEncryptionKey :one
INSERT INTO encryption_keys (
  device_id, identity_key, prekey_public, prekey_signature
) VALUES (
  $1, $2, $3, $4
)
RETURNING device_id, identity_key, prekey_public, prekey_signature
`

type CreateEncryptionKeyParams struct {
	DeviceID        pgtype.UUID
	IdentityKey     string
	PrekeyPublic    string
	PrekeySignature string
}

func (q *Queries) CreateEncryptionKey(ctx context.Context, arg CreateEncryptionKeyParams) (EncryptionKey, error) {
	row := q.db.QueryRow(ctx, createEncryptionKey,
		arg.DeviceID,
		arg.IdentityKey,
		arg.PrekeyPublic,
		arg.PrekeySignature,
	)
	var i EncryptionKey
	err := row.Scan(
		&i.DeviceID,
		&i.IdentityKey,
		&i.PrekeyPublic,
		&i.PrekeySignature,
	)
	return i, err
}

const deleteEncryptionKey = `-- name: DeleteEncryptionKey :exec
DELETE FROM encryption_keys
WHERE device_id = $1
`

func (q *Queries) DeleteEncryptionKey(ctx context.Context, deviceID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteEncryptionKey, deviceID)
	return err
}

const deleteEncryptionKeysByUser = `-- name: DeleteEncryptionKeysByUser :exec
DELETE FROM encryption_keys
WHERE device_id IN (
  SELECT id FROM user_devices WHERE user_id = $1
)
`

func (q *Queries) DeleteEncryptionKeysByUser(ctx context.Context, userID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteEncryptionKeysByUser, userID)
	return err
}

const getDeviceEncryptionKey = `-- name: GetDeviceEncryptionKey :one
SELECT device_id, identity_key, prekey_public, prekey_signature FROM encryption_keys
WHERE device_id = $1 LIMIT 1
`

func (q *Queries) GetDeviceEncryptionKey(ctx context.Context, deviceID pgtype.UUID) (EncryptionKey, error) {
	row := q.db.QueryRow(ctx, getDeviceEncryptionKey, deviceID)
	var i EncryptionKey
	err := row.Scan(
		&i.DeviceID,
		&i.IdentityKey,
		&i.PrekeyPublic,
		&i.PrekeySignature,
	)
	return i, err
}

const getEncryptionKey = `-- name: GetEncryptionKey :one
SELECT device_id, identity_key, prekey_public, prekey_signature FROM encryption_keys
WHERE device_id = $1 LIMIT 1
`

func (q *Queries) GetEncryptionKey(ctx context.Context, deviceID pgtype.UUID) (EncryptionKey, error) {
	row := q.db.QueryRow(ctx, getEncryptionKey, deviceID)
	var i EncryptionKey
	err := row.Scan(
		&i.DeviceID,
		&i.IdentityKey,
		&i.PrekeyPublic,
		&i.PrekeySignature,
	)
	return i, err
}

const getEncryptionKeyWithDevice = `-- name: GetEncryptionKeyWithDevice :one
SELECT ek.device_id, ek.identity_key, ek.prekey_public, ek.prekey_signature, ud.device_name, ud.device_type, ud.public_key, ud.user_id
FROM encryption_keys ek
JOIN user_devices ud ON ek.device_id = ud.id
WHERE ek.device_id = $1 LIMIT 1
`

type GetEncryptionKeyWithDeviceRow struct {
	DeviceID        pgtype.UUID
	IdentityKey     string
	PrekeyPublic    string
	PrekeySignature string
	DeviceName      pgtype.Text
	DeviceType      pgtype.Text
	PublicKey       string
	UserID          pgtype.UUID
}

func (q *Queries) GetEncryptionKeyWithDevice(ctx context.Context, deviceID pgtype.UUID) (GetEncryptionKeyWithDeviceRow, error) {
	row := q.db.QueryRow(ctx, getEncryptionKeyWithDevice, deviceID)
	var i GetEncryptionKeyWithDeviceRow
	err := row.Scan(
		&i.DeviceID,
		&i.IdentityKey,
		&i.PrekeyPublic,
		&i.PrekeySignature,
		&i.DeviceName,
		&i.DeviceType,
		&i.PublicKey,
		&i.UserID,
	)
	return i, err
}

const listDevicesNeedingKeyRefresh = `-- name: ListDevicesNeedingKeyRefresh :many
SELECT ud.id, ud.user_id, ud.device_name, ud.device_type, ud.public_key, ud.created_at, u.phone_number, u.display_name
FROM user_devices ud
JOIN users u ON ud.user_id = u.id
WHERE ud.id NOT IN (SELECT device_id FROM encryption_keys)
ORDER BY ud.created_at DESC
`

type ListDevicesNeedingKeyRefreshRow struct {
	ID          pgtype.UUID
	UserID      pgtype.UUID
	DeviceName  pgtype.Text
	DeviceType  pgtype.Text
	PublicKey   string
	CreatedAt   pgtype.Timestamptz
	PhoneNumber string
	DisplayName pgtype.Text
}

func (q *Queries) ListDevicesNeedingKeyRefresh(ctx context.Context) ([]ListDevicesNeedingKeyRefreshRow, error) {
	rows, err := q.db.Query(ctx, listDevicesNeedingKeyRefresh)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDevicesNeedingKeyRefreshRow
	for rows.Next() {
		var i ListDevicesNeedingKeyRefreshRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.DeviceName,
			&i.DeviceType,
			&i.PublicKey,
			&i.CreatedAt,
			&i.PhoneNumber,
			&i.DisplayName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEncryptionKeys = `-- name: ListEncryptionKeys :many
SELECT device_id, identity_key, prekey_public, prekey_signature FROM encryption_keys
ORDER BY device_id
`

func (q *Queries) ListEncryptionKeys(ctx context.Context) ([]EncryptionKey, error) {
	rows, err := q.db.Query(ctx, listEncryptionKeys)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EncryptionKey
	for rows.Next() {
		var i EncryptionKey
		if err := rows.Scan(
			&i.DeviceID,
			&i.IdentityKey,
			&i.PrekeyPublic,
			&i.PrekeySignature,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEncryptionKeysByUser = `-- name: ListEncryptionKeysByUser :many
SELECT ek.device_id, ek.identity_key, ek.prekey_public, ek.prekey_signature, ud.device_name, ud.device_type
FROM encryption_keys ek
JOIN user_devices ud ON ek.device_id = ud.id
WHERE ud.user_id = $1
ORDER BY ek.device_id
`

type ListEncryptionKeysByUserRow struct {
	DeviceID        pgtype.UUID
	IdentityKey     string
	PrekeyPublic    string
	PrekeySignature string
	DeviceName      pgtype.Text
	DeviceType      pgtype.Text
}

func (q *Queries) ListEncryptionKeysByUser(ctx context.Context, userID pgtype.UUID) ([]ListEncryptionKeysByUserRow, error) {
	rows, err := q.db.Query(ctx, listEncryptionKeysByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListEncryptionKeysByUserRow
	for rows.Next() {
		var i ListEncryptionKeysByUserRow
		if err := rows.Scan(
			&i.DeviceID,
			&i.IdentityKey,
			&i.PrekeyPublic,
			&i.PrekeySignature,
			&i.DeviceName,
			&i.DeviceType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEncryptionKeysWithDeviceInfo = `-- name: ListEncryptionKeysWithDeviceInfo :many
SELECT ek.device_id, ek.identity_key, ek.prekey_public, ek.prekey_signature, ud.device_name, ud.device_type, ud.public_key, 
       u.phone_number, u.display_name
FROM encryption_keys ek
JOIN user_devices ud ON ek.device_id = ud.id
JOIN users u ON ud.user_id = u.id
ORDER BY u.phone_number, ud.device_name
`

type ListEncryptionKeysWithDeviceInfoRow struct {
	DeviceID        pgtype.UUID
	IdentityKey     string
	PrekeyPublic    string
	PrekeySignature string
	DeviceName      pgtype.Text
	DeviceType      pgtype.Text
	PublicKey       string
	PhoneNumber     string
	DisplayName     pgtype.Text
}

func (q *Queries) ListEncryptionKeysWithDeviceInfo(ctx context.Context) ([]ListEncryptionKeysWithDeviceInfoRow, error) {
	rows, err := q.db.Query(ctx, listEncryptionKeysWithDeviceInfo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListEncryptionKeysWithDeviceInfoRow
	for rows.Next() {
		var i ListEncryptionKeysWithDeviceInfoRow
		if err := rows.Scan(
			&i.DeviceID,
			&i.IdentityKey,
			&i.PrekeyPublic,
			&i.PrekeySignature,
			&i.DeviceName,
			&i.DeviceType,
			&i.PublicKey,
			&i.PhoneNumber,
			&i.DisplayName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEncryptionKey = `-- name: UpdateEncryptionKey :one
UPDATE encryption_keys
SET identity_key = $2,
    prekey_public = $3,
    prekey_signature = $4
WHERE device_id = $1
RETURNING device_id, identity_key, prekey_public, prekey_signature
`

type UpdateEncryptionKeyParams struct {
	DeviceID        pgtype.UUID
	IdentityKey     string
	PrekeyPublic    string
	PrekeySignature string
}

func (q *Queries) UpdateEncryptionKey(ctx context.Context, arg UpdateEncryptionKeyParams) (EncryptionKey, error) {
	row := q.db.QueryRow(ctx, updateEncryptionKey,
		arg.DeviceID,
		arg.IdentityKey,
		arg.PrekeyPublic,
		arg.PrekeySignature,
	)
	var i EncryptionKey
	err := row.Scan(
		&i.DeviceID,
		&i.IdentityKey,
		&i.PrekeyPublic,
		&i.PrekeySignature,
	)
	return i, err
}

const updateIdentityKey = `-- name: UpdateIdentityKey :one
UPDATE encryption_keys
SET identity_key = $2
WHERE device_id = $1
RETURNING device_id, identity_key, prekey_public, prekey_signature
`

type UpdateIdentityKeyParams struct {
	DeviceID    pgtype.UUID
	IdentityKey string
}

func (q *Queries) UpdateIdentityKey(ctx context.Context, arg UpdateIdentityKeyParams) (EncryptionKey, error) {
	row := q.db.QueryRow(ctx, updateIdentityKey, arg.DeviceID, arg.IdentityKey)
	var i EncryptionKey
	err := row.Scan(
		&i.DeviceID,
		&i.IdentityKey,
		&i.PrekeyPublic,
		&i.PrekeySignature,
	)
	return i, err
}

const updatePrekey = `-- name: UpdatePrekey :one
UPDATE encryption_keys
SET prekey_public = $2,
    prekey_signature = $3
WHERE device_id = $1
RETURNING device_id, identity_key, prekey_public, prekey_signature
`

type UpdatePrekeyParams struct {
	DeviceID        pgtype.UUID
	PrekeyPublic    string
	PrekeySignature string
}

func (q *Queries) UpdatePrekey(ctx context.Context, arg UpdatePrekeyParams) (EncryptionKey, error) {
	row := q.db.QueryRow(ctx, updatePrekey, arg.DeviceID, arg.PrekeyPublic, arg.PrekeySignature)
	var i EncryptionKey
	err := row.Scan(
		&i.DeviceID,
		&i.IdentityKey,
		&i.PrekeyPublic,
		&i.PrekeySignature,
	)
	return i, err
}

const validatePrekeySignature = `-- name: ValidatePrekeySignature :one
SELECT EXISTS(
  SELECT 1 FROM encryption_keys
  WHERE device_id = $1 AND prekey_signature = $2
)
`

type ValidatePrekeySignatureParams struct {
	DeviceID        pgtype.UUID
	PrekeySignature string
}

func (q *Queries) ValidatePrekeySignature(ctx context.Context, arg ValidatePrekeySignatureParams) (bool, error) {
	row := q.db.QueryRow(ctx, validatePrekeySignature, arg.DeviceID, arg.PrekeySignature)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
